<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body onload="InitDemo();">
    <canvas id="shader">

    </canvas>
</body>
<script id="draw-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    void main(void) {
        gl_Position = vec4(aVertexPosition, 1.0);
    }
</script>
<script id="draw-shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    uniform highp float uTime;
    uniform vec2 uRes;

    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        float scale = 0.01;
        float time = uTime * 100.0;
        float r1 = 0.4 ;
        float r2 = 0.9 ;
        float r3 = 0.29;
        float x = gl_FragCoord.x;
        float y = gl_FragCoord.y;
        float h = uRes.y;
        float w = uRes.x;


        float col =
        sin(distance( vec2(x * r1 + time, y * r2), vec2(w / r3 , h) ) * scale) +
        sin(distance( vec2(x, y * r2), vec2(1.0 / h * r3, w * r1) ) * scale) +
        sin(distance( vec2(r3 * x + time, r1 * y + time), vec2(w * r2 + h * r1, h * r2) ) * scale) +
        sin(distance( vec2(1.0 / x * r3 , y * r2), vec2(h, w) ) * scale);

        vec3 color = vec3( 0.5 + 0.5 * sin(col), cos(col), cos(col) - sin(col)) + 0.1;
        color += mod(gl_FragCoord.x, 2.0) < 1.0 ? 0.0 : 0.4;

        fragColor = vec4(color, 0.5);
    }

    void main()
    {
        mainImage( gl_FragColor, gl_FragCoord.xy );
    }
</script>

<script>
    var canvas = document.getElementById("shader");
    var gl = canvas.getContext('webgl');
    var bufObj = {};
    var InitDemo = function (){
        console.log("Okay");

        if(!gl)  gl = canvas.getContext('experimental-webgl');
        //
        // gl.clearColor(0.8, 0.2, 0.5, 1.0);
        // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        program = gl.createProgram();
        for (let i = 0; i < 2; ++i) {

            let source = document.getElementById(i===0 ? "draw-shader-vs" : "draw-shader-fs").text;
            let shaderObj = gl.createShader(i===0 ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);

            gl.shaderSource(shaderObj, source);
            gl.compileShader(shaderObj);

            let status = gl.getShaderParameter(shaderObj, gl.COMPILE_STATUS);

            if (!status) alert(gl.getShaderInfoLog(shaderObj));

            gl.attachShader(program, shaderObj);
            gl.linkProgram(program);

        }


        if ( !status ) alert(gl.getProgramInfoLog(program));
        program.aVertexPosition = gl.getUniformLocation(program, "aVertexPosition");
        program.uTime = gl.getUniformLocation(program, "uTime");
        program.uRes = gl.getUniformLocation(program, "uRes");
        gl.useProgram(program);
        var pos = [1, 1,
            1, 1,
            1, 1,
            1, 1,
            1, 1,
            1, 1];
        var inx = [ 0, 1, 2, 0, 2, 3 ];
        bufObj.pos = gl.createBuffer();
        gl.bindBuffer( gl.ARRAY_BUFFER, bufObj.pos );
        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array(pos),gl.STATIC_DRAW);

        bufObj.inx = gl.createBuffer();
        bufObj.inx.len = inx.length;

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, bufObj.inx );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint16Array( inx ), gl.STATIC_DRAW );

        gl.enableVertexAttribArray( program.aVertexPosition );
        gl.vertexAttribPointer(  program.aVertexPosition, 2, gl.FLOAT, false, 0, 0 );

        // gl.uniform2fv(program.uResolution, [1000,1000]);

        gl.clearColor( 0.0, 0.0, 0.0, 1.0 );
        window.onresize = resize;
        resize();
        requestAnimationFrame(drawScene);


    }

    function resize(){
        vp_size = window.innerWidth * 0.7;
        canvas.width = vp_size;
        canvas.height = vp_size;
    }

    function drawScene(deltaMS){
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

        gl.uniform1f(program.uTime, deltaMS/1000.0);


        gl.drawElements( gl.TRIANGLES, bufObj.inx.len, gl.UNSIGNED_SHORT, 0 );
        // gl.drawArrays(gl.TRIANGLES, 0, 0);
        requestAnimationFrame(drawScene);
    }



    //
    // var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    // var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    //
    // gl.shaderSource(vertexShader, vertexShaderText);
    // gl.shaderSource(fragmentShader, fragmentShaderText);
    //
    // gl.compileShader(vertexShader);
    // if( !gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
    //     console.log("Error" + gl.getShaderInfoLog(vertexShader));
    // }
    //
    // if( !gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
    //     console.log("Error" + gl.getShaderInfoLog(fragmentShader));
    // }
    //
    // gl.compileShader(fragmentShader);
    //
    //
    //
    // if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
    //     console.log("" +gl.getProgramInfoLog(program));
    // }
    //
    // gl.validateProgram(program);
    //
    // var triangleVertices = [
    //     1.0, 1.0, 0.5, 0.0, 0.2,
    //     -1.0, -1.0, 0.2, 0.7, 0.2,
    //     0.5, 1.0, 0.5, 0.3, 0.2,
    //     0.8, 0.8, 0.5, 0.3, 0.8,
    // ];
    // var pos = [ 1,1,1,1,-1,-1,-1,-1  ];
    // var inx = [ 0, 1, 3, 1, 2, 3 ];
    // var triangleVertexBufferObject = gl.createBuffer();
    // gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexBufferObject);
    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
    //
    // var asd = gl.createBuffer();
    // asd.len = inx.length;
    //
    // gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, asd );
    // gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint16Array( inx ), gl.STATIC_DRAW );
    // gl.enableVertexAttribArray( triangleVertexBufferObject );
    // gl.vertexAttribPointer( triangleVertexBufferObject, 2, gl.FLOAT, false, 0, 0 );
    //
    // var positionAttribLocation = gl.getAttribLocation(program, 'vertPosition');
    // var colorAttribLocation = gl.getAttribLocation(program, 'vertColor');
    // gl.vertexAttribPointer(
    //     positionAttribLocation,
    //     2,
    //     gl.FLOAT,
    //     gl.FALSE,
    //     5 * Float32Array.BYTES_PER_ELEMENT, //konstans = 4
    //     0
    // );
    //
    // gl.vertexAttribPointer(
    //     colorAttribLocation,
    //     3,
    //     gl.FLOAT,
    //     gl.FALSE,
    //     5 * Float32Array.BYTES_PER_ELEMENT, //konstans = 4
    //     6 * Float32Array.BYTES_PER_ELEMENT
    // );
    //
    // status = gl.getProgramParameter(progDraw, gl.LINK_STATUS);
</script>
</html>